/*
 * ------------------------------------------------------------------------------
 * Project: symon
 * Version: 0.0.1
 * Description: Tiny Command Line Interface Remote System Monitor.
 * Author: lzcdr
 * Date: 2024-03-04 10:07:41
 * ------------------------------------------------------------------------------
 * This file was automatically generated by the Bytesnap RPC (version 0.1.0) 
 * project generator.
 * ------------------------------------------------------------------------------
 */

// 
// vst_io_context_pool.hpp
// ---------------
// tcp/ip client/server framework based on boost::asio
// using custom protocol with a fixed length message header
// and variable length message body
//
// Copyright(c) 2024-present, lzcdr
//
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#ifndef VST_IO_CONTEXT_POOL_HPP
#define VST_IO_CONTEXT_POOL_HPP

#include <boost/asio.hpp>
#include <memory>
#include <vector>

namespace vst
{

/**
 * @brief pool of boost::asio::io_context instances
 * 
 */
class io_context_pool
{
public:
    // non-copyable
    io_context_pool(const io_context_pool&) = delete;
    io_context_pool& operator=(const io_context_pool&) = delete;

    /**
     * @brief Construct a new io_context_pool object
     * 
     * @param pool_size number of boost::asio::io_context instances in the pool
     */
    explicit io_context_pool(std::size_t pool_size)
        : next_io_context_(0)
    {
        if (pool_size == 0) {
            throw std::runtime_error("io_context_pool size is 0");
        }

        for (std::size_t i = 0; i < pool_size; ++i) {
            io_context_ptr io_context(new boost::asio::io_context);
            io_contexts_.push_back(io_context);
            work_.push_back(boost::asio::make_work_guard(*io_context));
        }
    }

    /**
     * @brief Run boost::asio::io_context instances in separate threads
     * 
     */
    void run()
    {
        std::vector<std::thread> threads;
        for (std::size_t i = 0; i < io_contexts_.size(); ++i) {
            threads.emplace_back([this, i]{ io_contexts_[i]->run(); });
        }

        for (std::size_t i = 0; i < threads.size(); ++i) {
            threads[i].join();
        }
    }

    /**
     * @brief Stop boost::asio::io_context instances
     * 
     */
    void stop()
    {
        for (std::size_t i = 0; i < io_contexts_.size(); ++i) {
            io_contexts_[i]->stop();
        }
    }

    /**
     * @brief Get the io_context_object instance using round-robin
     * 
     * @return boost::asio::io_context& 
     */
    boost::asio::io_context& get_io_context()
    {
        boost::asio::io_context& io_context = *io_contexts_[next_io_context_];
        ++next_io_context_;
        if (next_io_context_ == io_contexts_.size()) {
            next_io_context_ = 0;
        }
        return io_context;
    }

private:
    typedef std::shared_ptr<boost::asio::io_context> io_context_ptr;
    typedef boost::asio::executor_work_guard<boost::asio::io_context::executor_type> io_context_work;

    std::vector<io_context_ptr> io_contexts_;
    std::vector<io_context_work> work_;
    std::size_t next_io_context_;
};

} // namespace vst

#endif // VST_IO_CONTEXT_POOL_HPP
